# Developer Instruction Set #1 -- Calculator API Build

**Date:** 2026-02-18
**Author:** Architect Agent (Step 4 -- Synthesize Pre-Build Findings)
**Companion spec:** `/Users/pudubrewshowie/code-repose/github/calculator-test/calculator-app-spec.md`

---

## How to Read This Document

You are the Developer agent. This file is your complete, self-contained build instruction set. You must implement exactly what is described here. Do not deviate, improvise, or add features not listed. If something seems ambiguous, follow the exact wording in this document -- every decision has already been made. You may also reference the app spec for additional context, but this document takes precedence if there is any conflict.

---

## 1. Project Scaffold

| Property | Value |
|----------|-------|
| Folder name | `calculator-api` |
| Runtime | Node.js |
| Framework | Express.js |
| Language | JavaScript (CommonJS -- use `require`, not `import`) |
| Entry point | `index.js` |
| Port | `3000` |

### 1.1 Initialize the Project

```bash
cd calculator-api
npm init -y
npm install express
```

### 1.2 Required Files

You must produce exactly these three files:

| File | Purpose |
|------|---------|
| `index.js` | Main server file. Contains all middleware, routes, and error handling. Single file. |
| `package.json` | Generated by `npm init`, with `express` as a dependency. Add a `"start"` script: `"node index.js"` |
| `README.md` | Documents how to install, run, and use the API with example curl commands for all 4 endpoints |

Do not create any other files. No `src/` folder, no `routes/` folder, no `utils/` folder, no test files.

---

## 2. Server Configuration

At the top of `index.js`, configure the Express app with these settings in this exact order:

1. **Disable `X-Powered-By` header:** `app.disable('x-powered-by')` -- must be called before any routes or middleware.
2. **Content-Type validation middleware** (custom -- see Section 4.1 below). This must run BEFORE `express.json()`.
3. **JSON body parser with size limit:** `express.json({ limit: '1kb', strict: false })` -- the `strict: false` is required (see Section 6.3 for why). The `limit: '1kb'` enforces a maximum payload size.
4. **JSON parse error handler** (custom -- see Section 4.2 below). This must run immediately after `express.json()`.
5. **Route definitions** (see Section 3).

At the bottom of `index.js`, start the server:

```javascript
app.listen(3000, () => {
  console.log('Calculator API running on port 3000');
});
```

Export the app for potential testing:

```javascript
module.exports = app;
```

---

## 3. Endpoints

All four endpoints are `POST` only. Each accepts a JSON body with fields `a` and `b` and returns a JSON response.

### 3.1 Success Response Shape (HTTP 200)

```json
{
  "operation": "<operation name string>",
  "a": <the validated input a>,
  "b": <the validated input b>,
  "result": <the computed integer result>
}
```

### 3.2 Error Response Shape (HTTP 400)

```json
{
  "error": "<exact error message string>"
}
```

### 3.3 Endpoint Definitions

| # | Method | Path | Operation Name (verbatim string) | Computation |
|---|--------|------|----------------------------------|-------------|
| 1 | POST | `/add` | `"addition"` | `a + b` |
| 2 | POST | `/subtract` | `"subtraction"` | `a - b` |
| 3 | POST | `/multiply` | `"multiplication"` | `a * b` |
| 4 | POST | `/divide` | `"division"` | `Math.floor(a / b)` |

**The operation name strings must be exactly as shown.** They are lowercase. They are the full English word, not the verb (e.g. `"addition"`, not `"add"`).

### 3.4 Route Handler Structure

Each route handler must:

1. Run the shared validation function (Section 5) passing `req.body` and the endpoint path.
2. If validation returns an error, respond with `res.status(400).json({ error: errorMessage })` and return.
3. If validation passes, extract `a` and `b` from `req.body`.
4. Compute the result.
5. Respond with `res.status(200).json({ operation, a, b, result })`.

---

## 4. Middleware -- Exact Order and Implementation

The middleware order is critical. Express processes middleware in the order it is registered. The wrong order will produce wrong error messages, wrong HTTP status codes, or server crashes.

### 4.1 Content-Type Validation Middleware (BEFORE `express.json()`)

This middleware must run on every request BEFORE `express.json()` parses the body. It checks Rule 1.

```javascript
app.use((req, res, next) => {
  if (!req.is('application/json')) {
    return res.status(400).json({ error: 'Content-Type must be application/json' });
  }
  next();
});
```

**Why `req.is()` instead of string comparison:** The `req.is('application/json')` method (provided by Express) correctly handles:
- `application/json; charset=utf-8` -- returns `'application/json'` (truthy)
- `text/plain` -- returns `false`
- Missing Content-Type header -- returns `false`

A string comparison like `req.headers['content-type'] === 'application/json'` would INCORRECTLY reject `application/json; charset=utf-8`, which many HTTP clients send by default.

### 4.2 JSON Parse Error Handler (AFTER `express.json()`)

Express's `express.json()` middleware throws a `SyntaxError` when the body is not valid JSON. The default Express error response does NOT match the spec's required error message. You must intercept it.

Register this error-handling middleware immediately after `express.json()`:

```javascript
app.use((err, req, res, next) => {
  if (err.type === 'entity.parse.failed') {
    return res.status(400).json({ error: 'Invalid JSON body' });
  }
  if (err.type === 'entity.too.large') {
    return res.status(400).json({ error: 'Invalid JSON body' });
  }
  next(err);
});
```

**Why check `err.type`:** Express's body-parser sets `err.type` to `'entity.parse.failed'` for JSON syntax errors and `'entity.too.large'` for payloads exceeding the size limit. Checking `err.type` is more reliable than checking `err instanceof SyntaxError` because other middleware could also throw `SyntaxError` for unrelated reasons.

---

## 5. Validation Function

Create a single validation function that all four route handlers call. This ensures the six rules are checked in the exact same order for every endpoint.

### 5.1 Validation Rules -- Exact Order

The rules below must be checked in this exact sequence. If a rule fails, return the error message immediately. Do NOT continue to later rules.

| Priority | Rule | Verbatim Error Message String |
|----------|------|-------------------------------|
| 1 | Content-Type must be `application/json` | `"Content-Type must be application/json"` |
| 2 | Body must be valid JSON | `"Invalid JSON body"` |
| 3 | Both `a` and `b` must be present (key exists in body) | `"Both a and b are required"` |
| 4 | Both `a` and `b` must be integers | `"Both a and b must be integers"` |
| 5 | Both `a` and `b` must be in range [-1000000, 1000000] | `"Values must be between -1000000 and 1000000"` |
| 6 | For `/divide` only: `b` must not be zero | `"Division by zero is not allowed"` |

**Rules 1 and 2 are handled by middleware** (Sections 4.1 and 4.2). By the time the route handler runs, Rules 1 and 2 have already passed. The validation function in the route handler checks Rules 3 through 6.

### 5.2 Validation Function Implementation

```javascript
function validate(body, path) {
  const a = body === null || body === undefined ? undefined : body.a;
  const b = body === null || body === undefined ? undefined : body.b;

  // Rule 3: Both a and b must be present (key exists)
  if (a === undefined || b === undefined) {
    return 'Both a and b are required';
  }

  // Rule 4: Both a and b must be integers
  if (!Number.isInteger(a) || !Number.isInteger(b)) {
    return 'Both a and b must be integers';
  }

  // Rule 5: Both a and b must be in range [-1000000, 1000000] inclusive
  if (a < -1000000 || a > 1000000 || b < -1000000 || b > 1000000) {
    return 'Values must be between -1000000 and 1000000';
  }

  // Rule 6: Division by zero (only for /divide)
  if (path === '/divide' && b === 0) {
    return 'Division by zero is not allowed';
  }

  return null; // No error
}
```

### 5.3 Critical Rule-by-Rule Implementation Notes

**Rule 3 -- "present" means the key exists (value is not `undefined`):**
- `{ "a": 10 }` -- `b` is absent (`undefined`) -- triggers Rule 3.
- `{ "a": null, "b": 5 }` -- `a` is present (key exists) but value is `null` -- does NOT trigger Rule 3. Falls through to Rule 4.
- `{}` -- both `a` and `b` are absent -- triggers Rule 3.
- Use `=== undefined` (strict equality). Do NOT use `== null` (loose equality), which would match both `null` and `undefined` and incorrectly catch `null` at Rule 3.

**Rule 4 -- use `Number.isInteger()`:**
- `Number.isInteger(null)` returns `false` -- correctly caught here.
- `Number.isInteger(1.5)` returns `false` -- correctly caught.
- `Number.isInteger("5")` returns `false` -- correctly caught.
- `Number.isInteger(true)` returns `false` -- correctly caught.
- `Number.isInteger(Infinity)` returns `false` -- correctly caught (this can appear via JSON like `1e999`).
- `Number.isInteger(1.0)` returns `true` -- correctly accepted (in JavaScript, `1.0 === 1`).

**Rule 4 checks BOTH `a` and `b` before moving to Rule 5.** This means: if `a` is a valid integer but `b` is a string, Rule 4 fires (not Rule 5 for `a`). The validation is per-rule, not per-field. Example: `{ "a": 5000000, "b": "hello" }` must return Rule 4's error, because `b` fails Rule 4. It must NOT return Rule 5's error even though `a` fails Rule 5.

**Rule 5 -- boundaries are inclusive:**
- `-1000000` is valid. `-1000001` is invalid.
- `1000000` is valid. `1000001` is invalid.
- Use `<=` and `>=` comparisons, not `<` and `>`.

**Rule 6 -- check `b === 0` only on the `/divide` path:**
- This check runs AFTER Rule 5, so if `b` is out of range, Rule 5 catches it first.
- Example: `POST /divide { "a": 2000000, "b": 0 }` returns Rule 5's error (not Rule 6), because `a` is out of range and Rule 5 is checked before Rule 6.

### 5.4 Body Guard for Non-Object JSON

When `express.json({ strict: false })` is used, the parsed body can be a number, string, boolean, array, or `null` (all valid JSON). If `body` is `null`, accessing `body.a` throws a `TypeError`. The validation function (Section 5.2) guards against this by checking `body === null || body === undefined` before accessing `.a` and `.b`. This ensures non-object JSON bodies fall through to Rule 3 ("Both a and b are required") instead of crashing the server.

---

## 6. Critical Implementation Requirements

These requirements address specific JavaScript and Express.js traps that will produce incorrect behavior if ignored.

### 6.1 Floor Division -- Use `Math.floor()`, Not Truncation

For the `/divide` endpoint, compute the result as:

```javascript
const result = Math.floor(a / b);
```

**Why this matters with negative numbers:**

| Expression | `Math.floor()` (CORRECT) | `Math.trunc()` (WRONG) | `\| 0` (WRONG) | `parseInt()` (WRONG) |
|------------|--------------------------|------------------------|-----------------|----------------------|
| `-7 / 2` | `-4` | `-3` | `-3` | `-3` |
| `7 / -2` | `-4` | `-3` | `-3` | `-3` |
| `-7 / -2` | `3` | `3` | `3` | `3` |
| `10 / 3` | `3` | `3` | `3` | `3` |

`Math.floor()` rounds toward negative infinity. `Math.trunc()` rounds toward zero. They produce identical results for positive numbers but different results when the quotient is negative. The spec says "floored," which means `Math.floor()`.

**Example test case the adversary WILL send:** `POST /divide { "a": -7, "b": 2 }` must return `{ "result": -4 }`. If you use `Math.trunc()`, it returns `-3` and the test fails.

### 6.2 Do NOT Apply Range Checks to the Computed Result

Range validation (Rule 5) applies only to the INPUT values `a` and `b`. The computed result is never range-checked.

Valid examples that produce out-of-range results:
- `POST /multiply { "a": 1000000, "b": 1000000 }` returns `{ "result": 1000000000000 }` -- this is correct.
- `POST /add { "a": 1000000, "b": 1000000 }` returns `{ "result": 2000000 }` -- this is correct.
- `POST /subtract { "a": -1000000, "b": 1000000 }` returns `{ "result": -2000000 }` -- this is correct.

Do NOT add defensive range checks on the result. The test agent will send max-range multiplication and expects a result of 1000000000000 (10^12).

### 6.3 Express `strict: false` for JSON Parsing

Configure `express.json()` with `strict: false`:

```javascript
app.use(express.json({ limit: '1kb', strict: false }));
```

**Why:** With the default `strict: true`, Express rejects bare JSON primitives (like `42`, `"hello"`, `true`, `null`) as parse errors, which would trigger Rule 2 ("Invalid JSON body"). But these ARE valid JSON per RFC 8259. The correct behavior per the spec is: they pass Rule 2 (valid JSON) and fail at Rule 3 (a and b are missing). Setting `strict: false` allows Express to parse all valid JSON, and then the validation function correctly handles non-object bodies via the null/undefined guard (Section 5.4).

### 6.4 Disable `X-Powered-By` Header

```javascript
app.disable('x-powered-by');
```

This must be called before any middleware or routes are registered.

### 6.5 Payload Size Limit

The `express.json({ limit: '1kb' })` configuration (Section 6.3) enforces a 1KB maximum request body size. Payloads exceeding this limit trigger Express's `entity.too.large` error, which the JSON parse error handler (Section 4.2) catches and returns as Rule 2's error message.

---

## 7. What NOT to Do -- Explicit Prohibitions

These are common JavaScript and Express.js patterns that will cause test failures. Do not use any of them.

### 7.1 Do NOT use bitwise OR (`| 0`) anywhere in arithmetic

```javascript
// WRONG -- truncates to 32-bit signed integer, silently produces garbage for large results
const result = (a * b) | 0;  // 1000000 * 1000000 | 0 = -727379968 (WRONG)

// WRONG -- truncates toward zero, not toward negative infinity
const result = (a / b) | 0;  // -7 / 2 | 0 = -3 (WRONG, should be -4)
```

The bitwise OR operator converts its operand to a 32-bit signed integer. This causes two bugs:
1. Multiplication of large values overflows 32 bits and wraps to a garbage negative number.
2. Division truncates toward zero instead of toward negative infinity.

### 7.2 Do NOT use `Math.trunc()` for division

```javascript
// WRONG
const result = Math.trunc(a / b);  // -7 / 2 = -3 (WRONG, should be -4)
```

### 7.3 Do NOT use `parseInt()` for division

```javascript
// WRONG
const result = parseInt(a / b);  // Same problem as Math.trunc()
```

### 7.4 Do NOT use loose equality (`==`) for the undefined check in Rule 3

```javascript
// WRONG -- catches both null and undefined, making null trigger Rule 3 instead of Rule 4
if (a == null || b == null) { ... }

// CORRECT -- catches only undefined
if (a === undefined || b === undefined) { ... }
```

### 7.5 Do NOT validate per-field (type then range for a, then type then range for b)

```javascript
// WRONG -- validates a through all rules, then b through all rules
if (!Number.isInteger(a)) return 'Both a and b must be integers';
if (a < -1000000 || a > 1000000) return 'Values must be between -1000000 and 1000000';
if (!Number.isInteger(b)) return 'Both a and b must be integers';
if (b < -1000000 || b > 1000000) return 'Values must be between -1000000 and 1000000';
```

This produces the wrong error for `{ "a": 5000000, "b": "hello" }`. The per-field approach returns Rule 5's error (because `a` fails range), but the correct answer is Rule 4's error (because `b` fails type, and Rule 4 is checked before Rule 5 for BOTH fields).

```javascript
// CORRECT -- validates per-rule: check both a and b for type, then check both for range
if (!Number.isInteger(a) || !Number.isInteger(b)) return 'Both a and b must be integers';
if (a < -1000000 || a > 1000000 || b < -1000000 || b > 1000000) return 'Values must be between -1000000 and 1000000';
```

### 7.6 Do NOT range-check the computed result

```javascript
// WRONG -- rejects valid operations whose results exceed input range
if (result < -1000000 || result > 1000000) { return error; }
```

### 7.7 Do NOT destructure the body without a null guard

```javascript
// WRONG -- crashes with TypeError if body is null (valid JSON, parsed by strict: false)
const { a, b } = req.body;

// CORRECT -- guard against null/undefined body first
const a = req.body === null || req.body === undefined ? undefined : req.body.a;
const b = req.body === null || req.body === undefined ? undefined : req.body.b;
```

### 7.8 Do NOT rely on Express's default JSON parse error message

Express returns error messages like `"Unexpected token 'n', \"not json\" is not valid JSON"`. The spec requires exactly `"Invalid JSON body"`. The custom error handler (Section 4.2) replaces Express's message.

### 7.9 Do NOT use the `method-override` middleware or honor `X-HTTP-Method-Override` headers

All endpoints are POST only. Do not install any middleware that allows HTTP method overriding.

### 7.10 Do NOT add CORS headers

No CORS middleware. No `Access-Control-Allow-Origin` headers. The API does not need cross-origin support.

---

## 8. Complete Middleware and Route Registration Order

This is the exact order of `app.use()` and `app.post()` calls in `index.js`:

```
1. app.disable('x-powered-by')
2. app.use(contentTypeMiddleware)        -- Section 4.1
3. app.use(express.json({ limit: '1kb', strict: false }))
4. app.use(jsonParseErrorHandler)        -- Section 4.2
5. app.post('/add', handler)
6. app.post('/subtract', handler)
7. app.post('/multiply', handler)
8. app.post('/divide', handler)
9. app.listen(3000)
```

This order ensures:
- Content-Type is checked BEFORE Express tries to parse the body (otherwise wrong Content-Type causes a server crash instead of a 400 error).
- JSON parse errors are caught with the correct error message.
- The `X-Powered-By` header is suppressed on all responses.
- Payload size is enforced at the middleware layer.

---

## 9. Verbatim Error Message Reference

Copy these strings exactly. Any deviation in capitalization, punctuation, spacing, or wording is a test failure.

```
"Content-Type must be application/json"
"Invalid JSON body"
"Both a and b are required"
"Both a and b must be integers"
"Values must be between -1000000 and 1000000"
"Division by zero is not allowed"
```

---

## 10. Example Route Handler

This is a reference implementation for one endpoint. All four follow the same pattern.

```javascript
app.post('/add', (req, res) => {
  const error = validate(req.body, req.path);
  if (error) {
    return res.status(400).json({ error });
  }
  const { a, b } = req.body;
  const result = a + b;
  res.status(200).json({ operation: 'addition', a, b, result });
});
```

For `/divide`, the computation line is:

```javascript
const result = Math.floor(a / b);
```

For `/subtract`:

```javascript
const result = a - b;
```

For `/multiply`:

```javascript
const result = a * b;
```

**Note:** After validation passes, it is safe to destructure `req.body` because the validation function has already confirmed that `body` is a non-null object with integer `a` and `b` fields.

---

## 11. Spec Changes Made by the Architect

The following changes were made to `calculator-app-spec.md` before this instruction set was written, to resolve ambiguities identified during pre-build review:

| Change | Reason |
|--------|--------|
| Rule 3 now explicitly states that `null` is NOT absent -- it is present but invalid, caught by Rule 4 | Resolved ambiguity: `{ "a": null, "b": 5 }` triggers Rule 4, not Rule 3 |
| Rule 1 now states the Content-Type check must accept media type parameters (e.g. `charset=utf-8`) | Prevents false rejection of standard HTTP clients |
| Rule 5 now explicitly says "inclusive" | Confirms `-1000000` and `1000000` are valid inputs |
| Added note that result values are never range-checked | Prevents incorrect rejection of valid operations like `1000000 * 1000000` |
| Division examples now include negative cases: `-7 / 2 = -4`, `7 / -2 = -4` | Makes floor-vs-truncate behavior unambiguous |
| Added Security Hardening section with 1KB payload limit and X-Powered-By removal | Addresses denial-of-service and server fingerprinting risks |
| Added explicit per-rule validation ordering note: "Each rule checks both a and b before moving to the next rule" | Prevents per-field validation ordering bugs |

---

## 12. Summary Checklist

Before declaring the build complete, verify:

- [ ] `app.disable('x-powered-by')` is called first
- [ ] Content-Type middleware runs BEFORE `express.json()`
- [ ] `express.json()` uses `{ limit: '1kb', strict: false }`
- [ ] Custom error handler catches `entity.parse.failed` and `entity.too.large`
- [ ] Validation checks Rule 3 with `=== undefined` (not `== null`)
- [ ] Validation checks Rule 4 with `Number.isInteger()`
- [ ] Validation is per-rule (both fields per rule), not per-field (all rules per field)
- [ ] Rule 5 uses `<=` and `>=` (inclusive boundaries)
- [ ] Division uses `Math.floor(a / b)` -- not `Math.trunc`, not `| 0`, not `parseInt`
- [ ] No range validation on computed results
- [ ] All six error message strings match verbatim (Section 9)
- [ ] All four operation name strings match verbatim: `"addition"`, `"subtraction"`, `"multiplication"`, `"division"`
- [ ] Server listens on port 3000
- [ ] `module.exports = app` is present
- [ ] `README.md` exists with install/run/usage instructions
- [ ] No extra files beyond `index.js`, `package.json`, `README.md`
